% % uncomment these to see what it looks like when a test fails
% (This should fail) {1} [2] assert-stack
% (This should fail) {{1} [1] assert-stack} assert-fails
(A value equals itself) {1} [1] assert-stack
(A value equals itself) {2} [2] assert-stack
(A list equals an equivalent list) {[]} [[]] assert-stack
(A list equals an equivalent list) {[1]} [[1]] assert-stack
(Bracket notation applies operations in the array) {[5 1 2 add]} [[5 3]] assert-stack
(Different values are different) {{1} [2] assert-stack} assert-fails
(Arrays with different values are different) {{[1]} [[2]] assert-stack} assert-fails
(Arrays with different values are different) {{[1]} [[1 1]] assert-stack} assert-fails
(should fail) {{0 1 2 5 index} [] assert-stack} assert-fails
(Uncaught exceptions are failures that are caught) {{pop} [] assert-stack} assert-fails
/debug { % message -- 
    pstack
    ==
} def

/items-at { % [a1 a2 ... ak] i -- a1[i] a2[i] ... ak[i]
    mark  % A i m
    3 -1 roll % i m A
    {  % i m ... aj
        dup type /arraytype eq {
            counttomark 1 add index % i m ... aj i
            1 index length mod
            get
        } if
    } forall % i m a1[i] ... ak[i]
    counttomark 2 add -2 roll pop pop % a1[i] ... ak[i]
} def 

/overk { % a1 a2 ... ak f k s n -- [a1[0] ... ak[0] a1[s-1] ... ak[s-1] f a1[s] ... ak[s] f ... a1[n] ... ak[n] f]
    2 index array  % a1 a2 ... ak f k s n A
    5 1 roll       % a1 a2 ... ak A f k s n
    2 index 5 add 4 roll % f k s n a1 a2 ak ... A
    astore [   % f k s n A [
    3 index 0 eq {
        5 index exec  % run f if s is 0
    } if
    0 1 counttomark 2 add index 1 sub % f k s n A [ ... 0 1 n-1
    { % f k s n A [ ... i
        counttomark 1 roll % [ i ... 
        counttomark 1 add index % ... A
        counttomark 1 sub index % ... A i
        items-at   % ... a1i a2i ... aki
        counttomark -1 roll
        counttomark 3 add index 1 sub % ... i s-1
        ge
        { counttomark 5 add index exec } if
    } for
    ]
    6 1 roll
    5 { pop } repeat
} bind def

/each { % [a1 a2 ... an] f -- [a1 f a2 f ... an f]
    1 1 3 index length    % a f 1 1 n
    overk
} bind def

/zipwith { % a1 a2 ... ak f k -- [a1[s1] ... ak[1] f ... a1[n] ... ak[n] f]
    2 index length zipwithn
} bind def

/zipwithn { % a1 a2 ... ak f k n -- [a1[s1] ... ak[1] f ... a1[n] ... ak[n] f]
    1 exch overk
} bind def

/reduce { % [a1 a2 ... an] f -- a1 f a2 f ... an f
    1 2 3 index length    % a f 1 2 n
    overk aload pop
} bind def

/xdebug { % f --
    dup debug
    exec
} bind def

/max {
    2 copy gt {
        pop
    } {
        exch pop
    } ifelse
} bind def

/longest-length { % a1 ... ak k -- length of longest
    array astore {
        dup type /arraytype ne {
            pop 1
        } {
            length
        } ifelse
    } each
    {max} reduce
} bind def

/no-arrays { % v1 ... vk k -- bool
    array astore {type /arraytype ne} each
    {and} reduce
} bind def

/rank-polymorphic { % v1 ... vk f k - effects of f
    dup 2 add copy exch pop no-arrays { % v1 ... vk f k
        pop exec
    } {
        dup 2 add copy exch pop  % ... v1 ... vk k
        longest-length           % v1 ... vk f k n
        3 copy pop userdict /rank-polymorphic get % v1 ... vk f k n f k {rp}
        3 array astore cvx       % v1 ... vk f k n {f k {rp}}
        4 -1 roll pop            % v1 ... vk k n {f k {rp}}
        3 1 roll                 % v1 ... vk {f k {rp}} k n
        zipwithn
    } ifelse
} def

/+ {
    {add} 2 rank-polymorphic
} bind def

% (sum reduce over an array should give the sum) {[5 3 2] {(before) debug add (after) debug} "} [10] assert-stack
(items-at adds the kth item from several arrays to the stack) {[[4 5 6] [7 8 9]] 1 items-at} [5 8] assert-stack
(sum reduce over an array should give the sum) {[5 3 2] {add} reduce} [10] assert-stack
(sum zipwith should be elementwise sum) {[5 3 2] [8 3 1] {add} 2 zipwith} [[13 6 3]] assert-stack
(sum zipwith should reuse elements) {[7 3] [8 3 1] {add} 2 zipwith} [[15 6 8]] assert-stack
(sum zipwith should allow scalar) {7 [8 3 1] {add} 2 zipwith} [[15 10 8]] assert-stack
(mapping the double over an array should double each element) {[5 3 2] {dup} each} [[5 5 3 3 2 2]] assert-stack
(mapping the double over an array should double each element) {[5 3 2] {dup add} each} [[10 6 4]] assert-stack
(mapping over and empty array should give an empty array) {[] {dup add} each} [[]] assert-stack
(longest-length works on scalars and arrays) {[2 5] 4 [5 3 2 1 8] [3 9 5] 4 longest-length} [5] assert-stack
(pervasive add works on scalar to array) {4 [3 9 5] +} [[7 13 9]] assert-stack
(pervasive add works on scalar to scalar) {[3 9 5] 4 +} [[7 13 9]] assert-stack
(pervasive add works on nested array to array) {[3 [9 5] 5] [1 5 3] +} [[4 [14 10] 8]] assert-stack