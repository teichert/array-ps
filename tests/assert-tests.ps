% % uncomment these to see what it looks like when a test fails
% (This should fail) {1} [2] assert-stack
% (This should fail) {{1} [1] assert-stack} assert-fails
(A value equals itself) {1} [1] assert-stack
(A value equals itself) {2} [2] assert-stack
(A list equals an equivalent list) {[]} [[]] assert-stack
(A list equals an equivalent list) {[1]} [[1]] assert-stack
(Bracket notation applies operations in the array) {[5 1 2 add]} [[5 3]] assert-stack
(Different values are different) {{1} [2] assert-stack} assert-fails
(Arrays with different values are different) {{[1]} [[2]] assert-stack} assert-fails
(Arrays with different values are different) {{[1]} [[1 1]] assert-stack} assert-fails
(should fail) {{0 1 2 5 index} [] assert-stack} assert-fails
(Uncaught exceptions are failures that are caught) {{pop} [] assert-stack} assert-fails
/debug { % message -- 
    pstack
    ==
} def

/over { % [a1 a2 ... an] f s -- [a1 ... as as+1 f ... an f]
    [        %  [a1 a2 ... an] f s m
    counttomark 3 add index   %  [a1 a2 ... an] f s m a
    0 counttomark 1 add index %  [a1 a2 ... an] f s m a 0 s
    getinterval aload pop     %  [a1 a2 ... an] f s m a1 ... as
    counttomark 3 add index   %  [a1 a2 ... an] f s m a1 ... as a
    counttomark 1 add index   %  [a1 a2 ... an] f s m a1 ... as a s
    dup neg                   %  [a1 a2 ... an] f s m a1 ... as a s -s
    2 index length add        %  [a1 a2 ... an] f s m a1 ... as a s n-s
    getinterval               %  [a1 a2 ... an] f s m a1 ... as [as+1 ... an]
    counttomark 2 add index   %  [a1 a2 ... an] f s m a1 ... as [as+1 ... an] f
    forall                    %  [a1 a2 ... an] f s m a1 ... as as+1 f ... an f
    counttomark 4 add -3 roll %  m a1 ... as as+1 f ... an f [a1 a2 ... an] f s
    pop pop pop               %  m a1 ... as as+1 f ... an
    ]
} def

/' { % [a1 a2 ... an] f -- [a1 f a2 f ... an f]
    0 over
} def

/" { % [a1 a2 ... an] f -- [a1 f a2 f ... an f]
    1 over aload pop
} def

% /' { % [a1 a2 ... an] f -- [a1 f a2 f ... an f]
%     [              %  [a1 a2 ... an] f m
%     3 1 roll       %  m [a1 a2 ... an] f
%     0 1            %  m [a1 a2 ... an] f 0 1
%     3 index length %  m [a1 a2 ... an] f 0 1 n
%     1 sub          %  m [a1 a2 ... an] f 0 1 n-1
%     % 4 -1 roll      %  m [a1 a2 ... an] 0 1 n-1 f
%     {              % ... i
%         counttomark 1 sub index  % ..... i a
%         exch                     % ..... a i
%         get        % ai
%         counttomark 2 sub index  % ..... ai f
%         exec       % f(ai)
%     }
%     for            %  m a f a1 f a2 f ... an f
%     counttomark -2 roll %  m a1 f a2 f ... an f a f 
%     pop pop
%     ]
% } def

% /" { % [a1 a2 ... an] f -- [a1 f a2 f ... an f]
%     [              %  [a1 a2 ... an] f m
%     3 1 roll       %  m [a1 a2 ... an] f
%     0 1            %  m [a1 a2 ... an] f 0 1
%     3 index length %  m [a1 a2 ... an] f 0 1 n
%     1 sub          %  m [a1 a2 ... an] f 0 1 n-1
%     % 4 -1 roll      %  m [a1 a2 ... an] 0 1 n-1 f
%     {              % ... i
%         counttomark 1 sub index  % ..... i a
%         exch dup                 % ..... a i i
%         3 1 roll  % i a i
%         get       % i ai
%         exch 0 eq
%         {}
%         {
%             counttomark 2 sub index  % ..... ai f
%             exec       % f(ai)
%         } ifelse
%     }
%     for            %  m a f a1 f a2 f ... an f
%     counttomark -2 roll %  m a1 f a2 f ... an f a f 
%     pop pop       
%     ]
%     aload pop
% } def

/xdebug { % f --
    dup debug
    exec
} def

% (sum reduce over an array should give the sum) {[5 3 2] {(before) debug add (after) debug} "} [10] assert-stack
(sum reduce over an array should give the sum) {[5 3 2] {add} "} [10] assert-stack
% (mapping the double over an array should double each element) {[5 3 2] {dup} '} [[5 5 3 3 2 2]] assert-stack
% (mapping the double over an array should double each element) {[5 3 2] {dup add} '} [[10 6 4]] assert-stack
% (mapping over and empty array should give an empty array) {[] {dup add} '} [[]] assert-stack
