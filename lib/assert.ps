% Test tracking variables (exception: test framework needs global state)
/test-count 0 def
/test-passed 0 def
/test-failed 0 def
/test-correct-failures 0 def
/suppress-failure-output false def

% capture-stack: ( code-block -- array )
% Execute code block and capture resulting stack as array
/capture-stack {
	mark                                           % code-block mark
	exch                                           % mark code-block
	exec                                           % mark ...results...
	counttomark                                    % mark ...results... count
	array astore                                   % array
	exch                                           % array mark
	pop                                            % array
} def

% increment-test-count: ( -- )
% Increment total test count
/increment-test-count {
	/test-count test-count 1 add def               % --
} def

% increment-passed: ( -- )
% Increment passed test count
/increment-passed {
	/test-passed test-passed 1 add def             % --
} def

% increment-failed: ( -- )
% Increment failed test count
/increment-failed {
	/test-failed test-failed 1 add def             % --
} def

% increment-correct-failures: ( -- )
% Increment correct failure count
/increment-correct-failures {
	/test-correct-failures test-correct-failures 1 add def % --
} def

% print-failure: ( message code-block actual expected -- )
% Print failure details if output is not suppressed
/print-failure {
	suppress-failure-output not                     % message code-block actual expected should-print?
	{
		(Assertion failed: ) print                  % message code-block actual expected
		4 1 roll                                    % code-block actual expected message
		=                                           % code-block actual expected
		(  Code:     ) print                        % code-block actual expected
		3 1 roll                                    % actual expected code-block
		==                                          % actual expected
		(  Actual:   ) print                        % actual expected
		exch                                        % expected actual
		==                                          % expected
		(  Expected: ) print                        % expected
		==                                          % --
	}{
		pop pop pop pop                             % --
	} ifelse                                       % --
} def

% test-report: ( -- )
% Report test results and exit with appropriate code
/test-report {
  (Test Results:) =                                % --
  (  Total:             ) print                    % --
  test-count =                                     % --
  (  Correct:           ) print                    % --
  test-passed test-correct-failures add =          % --
  (  Passed:            ) print                    % --
  test-passed =                                    % --
  (  Correct Failures:  ) print                    % --
  test-correct-failures =                          % --
  (  Failed:            ) print                    % --
  test-failed =                                    % --
  test-failed 0 gt                                 % bool
  { 1 }                                            % 1
  { 0 }                                            % 0
  ifelse                                           % exit-code
  quit                                             % --
} def

% arrays-equal: ( array1 array2 -- bool )
% Compare two arrays for deep equality  
/arrays-equal {
	% Save arrays to variables for easier access
	/arr2 exch def                                  % array1
	/arr1 exch def                                  % --
	
	% Check lengths
	arr1 length arr2 length eq                      % lengths-equal?
	{
		% Same length, check elements
		true                                        % result
		0 1 arr1 length 1 sub                       % result start step end
		{
			% Compare element at index i  
			/i exch def                             % result
			arr1 i get                              % result arr1[i]
			arr2 i get                              % result arr1[i] arr2[i]
			elements-equal                          % result elements-equal?
			and                                     % combined-result
		} for                                      % final-result
	}{
		% Different lengths
		false                                      % false
	} ifelse                                       % result
} def

% elements-equal: ( element1 element2 -- bool )
% Compare two elements, handling arrays recursively
/elements-equal {
	2 copy                                          % elem1 elem2 elem1 elem2
	type /arraytype eq                              % elem1 elem2 elem1 is-array?
	exch type /arraytype eq                         % elem1 elem2 is-array? elem2-is-array?
	and                                             % elem1 elem2 both-arrays?
	{
		arrays-equal                               % result
	}{
		eq                                         % result
	} ifelse                                       % result
} def

% assert-stack: ( message code-block expected-array -- )
% Execute code block and compare resulting stack with expected array
/assert-stack {
	increment-test-count                            % message code-block expected-array
	2 copy                                          % message code-block expected-array code-block expected-array
	exch                                            % message code-block expected-array expected-array code-block
	capture-stack                                   % message code-block expected-array expected-array actual-array
	exch                                            % message code-block expected-array actual-array expected-array
	arrays-equal                                    % message code-block expected-array passed?
	{
		increment-passed                            % message code-block expected-array
		pop pop pop                                 % --
	}{
		increment-failed                            % message code-block expected-array
		2 index                                     % message code-block expected-array code-block
		capture-stack                               % message code-block expected-array actual-array
		print-failure                               % --
	} ifelse                                       % --
} def

% assert-stack-unnamed: ( code-block expected-array -- )
% Execute code block and compare resulting stack with expected array (no message)
/assert-stack-unnamed {
	(Unnamed test)                                 % code-block expected-array message
	3 1 roll                                       % message code-block expected-array
	assert-stack                                   % --
} def

% suppress-output: ( -- )
% Enable output suppression for expected failures
/suppress-output {
	/suppress-failure-output true def               % --
} def

% restore-output: ( -- )
% Restore normal output after expected failures
/restore-output {
	/suppress-failure-output false def              % --
} def

% get-failure-count: ( -- count )
% Get current failure count
/get-failure-count {
	test-failed                                    % count
} def

% handle-expected-failure: ( original-failures -- )
% Handle case where expected failure occurred
/handle-expected-failure {
	/test-failed exch def                          % reset failure count to original
	increment-passed                               % --
	increment-correct-failures                     % --
} def

% assert-fails: ( message assertion-block -- )
% Execute assertion block and verify it fails (increments failure count)
/assert-fails {
	increment-test-count                            % message assertion-block
	get-failure-count                               % message assertion-block original-failures
	3 1 roll                                        % original-failures message assertion-block
	suppress-output                                 % original-failures message assertion-block
	exch                                           % original-failures assertion-block message
	exch                                           % original-failures message assertion-block
	exec                                           % original-failures (assertion block executes)
	restore-output                                 % original-failures
	dup                                            % original-failures original-failures
	get-failure-count                              % original-failures original-failures current-failures
	lt                                             % original-failures failure-occurred?
	{
		handle-expected-failure                    % --
	}{
		pop                                        % --
		increment-failed                           % --
		(Assert-fails failed: expected assertion to fail but it passed) =
	} ifelse                                       % --
} def
