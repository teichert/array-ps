% Test tracking variables (exception: test framework needs global state)
/test-count 0 def
/test-passed 0 def
/test-failed 0 def
/test-correct-failures 0 def
/suppress-failure-output false def

% test-report: ( -- )
% Report test results and exit with appropriate code
/test-report {
  (Test Results:) =                                % --
  (  Total:             ) print                    % --
  test-count =                                     % --
  (  Correct:           ) print                    % --
  test-passed test-correct-failures add =          % --
  (  Passed:            ) print                    % --
  test-passed =                                    % --
  (  Correct Failures:  ) print                    % --
  test-correct-failures =                          % --
  (  Failed:            ) print                    % --
  test-failed =                                    % --
  test-failed 0 gt                                 % bool
  { 1 }                                            % 1
  { 0 }                                            % 0
  ifelse                                           % exit-code
  quit                                             % --
} def

% arrays-equal: ( array1 array2 -- bool )
% Compare two arrays for deep equality  
/arrays-equal {
	% Save arrays to variables for easier access
	/arr2 exch def                                  % array1
	/arr1 exch def                                  % --
	
	% Check lengths
	arr1 length arr2 length eq                      % lengths-equal?
	{
		% Same length, check elements
		true                                        % result
		0 1 arr1 length 1 sub                       % result start step end
		{
			% Compare element at index i  
			/i exch def                             % result
			arr1 i get                              % result arr1[i]
			arr2 i get                              % result arr1[i] arr2[i]
			elements-equal                          % result elements-equal?
			and                                     % combined-result
		} for                                      % final-result
	}{
		% Different lengths
		false                                      % false
	} ifelse                                       % result
} def

% elements-equal: ( element1 element2 -- bool )
% Compare two elements, handling arrays recursively
/elements-equal {
	2 copy                                          % elem1 elem2 elem1 elem2
	type /arraytype eq                              % elem1 elem2 elem1 is-array?
	exch type /arraytype eq                         % elem1 elem2 is-array? elem2-is-array?
	and                                             % elem1 elem2 both-arrays?
	{
		arrays-equal                               % result
	}{
		eq                                         % result
	} ifelse                                       % result
} def

% assert-stack: ( message code-block expected-array -- )
% Execute code block and compare resulting stack with expected array
/assert-stack {
	/test-count test-count 1 add def               % message code-block expected-array
	
	% Save inputs to local variables
	/expected exch def                              % message code-block
	dup                                             % message code-block code-block
	% Convert to executable array for printing like {1}
	1 array astore cvx                              % message code-block executable-array
	/code-block-for-printing exch def              % message code-block
	/code-block exch def                           % message
	/message exch def                              % --
	
	% Execute code block and capture result as array
	mark                                           % mark
	code-block exec                                % mark ...results...
	counttomark                                    % mark ...results... count
	array astore                                   % actual-array
	/actual exch def                               % --
	cleartomark                                    % --
	
	% Compare arrays using deep equality
	actual                                          % actual
	expected                                        % actual expected
	arrays-equal                                    % comparison-result
	
	% Handle test result
	{
		% Test passed
		/test-passed test-passed 1 add def         % --
	}{
		% Test failed
		/test-failed test-failed 1 add def         % --
		suppress-failure-output not                 % should-print?
		{
			(Assertion failed: ) print              % --
			message =                               % --
			(  Code block:      ) print             % --
			code-block-for-printing ==              % --
			(  Actual stack:    ) print             % --
			actual ==                               % --
			(  Expected stack:  ) print             % --
			expected ==                             % --
		} if                                       % --
		% Don't stop - continue with other tests   % --
	} ifelse                                       % --
} def

% assert-stack-unnamed: ( code-block expected-array -- )
% Execute code block and compare resulting stack with expected array (no message)
/assert-stack-unnamed {
	% Stack: code-block expected-array
	(Unnamed test)                                 % code-block expected-array message
	3 1 roll                                       % message code-block expected-array
	assert-stack                                   % --
} def

% assert-fails: ( message assertion-block -- )
% Execute assertion block and verify it fails (increments failure count)
/assert-fails {
	% Stack: message assertion-block
	% Track this as a test
	/test-count test-count 1 add def               % message assertion-block
	
	% Save current failure count
	/saved-failed test-failed def                   % message assertion-block
	
	% Enable output suppression for expected failures  
	/suppress-failure-output true def               % message assertion-block
	
	% Execute the assertion block with the message on the stack
	% The assertion block contains calls like: {1} [2] assert-stack
	% which expects: message code-block expected-array assert-stack
	exec                                           % message ... (assertion block executes)
	
	% Restore output suppression
	/suppress-failure-output false def              % --
	
	% Check if a failure occurred
	test-failed saved-failed gt                     % did-fail?
	{
		% Expected failure occurred
		/test-failed saved-failed def              % reset failure count
		/test-passed test-passed 1 add def         % count as passed
		/test-correct-failures test-correct-failures 1 add def % track correct failure
	}{
		% No failure occurred when one was expected
		/test-failed test-failed 1 add def         % count as failed
		(Assert-fails test failed: Expected assertion to fail, but it passed) =
	} ifelse                                       % --
} def
