% creates an array consisting of items from the most recent mark
/marray {  % mark v1 v2 ... vn -- a
  counttomark array astore % m a
  exch pop                 % a
} bind def

/range1 { % n -- [0 1 2 ... n-1]
  mark 0 1             % n mark 0 1
  4 -1 roll            % mark 0 1 n
  1 sub                % mark 0 1 n-1
  {} for               % mark 0 1 2 ... n-1
  marray
} bind def

/' { % [v1 v2 ... vn] f n s -- [v1 f v2 f ... vn f]
  [ % as f n s [
    % take from 0 up to s-1
    counttomark 
    % execute f
    % take from s-1 to n-1, executing f after each
    3 2 roll    % as f [ n s
    1 sub       % as f [ n s-1
    exch 1 exch % as f [ s 1 n
    { 
    } forall
  ]   % a'
} bind def

/" { % [a1 a2 ... an] [b1 b2 ... bn] f -- [a1 b1 f a2 b2 f ... an bn f]
  3 1 roll mark        % f [a] [b] mark
  1 index length 1 sub % f [a] [b] mark len-1
  0 1                  % f [a] [b] mark len-1 0 1
  3 -1 roll            % f [a] [b] mark 0 1 len-1
  {
    counttomark 2 add index % f [a] [b] mark ... i [a]
    1 index get             % f [a] [b] mark ... i ai
    counttomark 1 add index % f [a] [b] mark ... i ai [b]
    3 -1 roll               % f [a] [b] mark ... ai [b] i
    get                     % f [a] [b] mark ... ai bi
    counttomark 3 add index % f [a] [b] mark ... ai bi f
    exec
  } for
  marray                    % f [a] [b] [r]
  4 1 roll                  % [r] f [a] [b]
  pop pop pop               % [r]
} bind def

% % pops a dyadic function from the stack and pushes a new function that applies the given scalar function pervasively
% % meaning that:
% % - if both operands are not arrays, then the raw function is called;
% % - if exactly one of the operands is not an array then the new function is recursively called (via each1) on each of the elements of the array
% /pervasive { % f -- f'
 
% } bind def

/+ { add } def