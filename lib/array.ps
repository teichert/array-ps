/dbg { % message -- 
    pstack
    ==
} bind def

/debug {
    (debug) dbg
} bind def

/xdebug { % f --
    dup debug
    exec
} bind def

/max {
    2 copy gt {
        pop
    } {
        exch pop
    } ifelse
} bind def

/min {
    2 copy lt {
        pop
    } {
        exch pop
    } ifelse
} bind def

/get-with-wrap { % a i -- a if a is not an array else a[i % a.length]
    1 index type /arraytype eq {
        1 index length mod
        get
    } {
        pop
    } ifelse
} bind def

/short-circuit-and { % b1 {b2} -- (b1 b2 and)
    exch dup { % {b2} b1
        exch exec % b1 b2
        and
    } { % {b2} b1
        pop pop false
    } ifelse
} bind def

/get-with-pad { % a i pad -- a[i] if a is an array and i < a.length, otherwise pad
    2 index type /arraytype eq   % a i pad isarray
    {
        2 index                      % a i pad isarray i
        4 index length lt            % a i pad isarray i<length
    } short-circuit-and {                        % a i pad
        pop get
    } {
        3 1 roll pop pop
    } ifelse
} bind def

/items-at { % [a1 a2 ... ak] i -- a1[i] a2[i] ... ak[i]
    mark  % A i m
    3 -1 roll % i m A
    {  % i m ... aj
        counttomark 1 add index % i m ... aj i
        get-with-wrap
    } forall % i m a1[i] ... ak[i]
    counttomark 2 add -2 roll pop pop % a1[i] ... ak[i]
} bind def 

/items-at-pad { % [a1 a2 ... ak] i pad -- a1[i] a2[i] ... ak[i]
    mark  % A i pad m
    4 -1 roll % i pad m A
    {  % i pad m ... aj
        counttomark 2 add index % i pad m ... aj i
        counttomark 1 add index % i pad m ... aj i pad
        get-with-pad
    } forall % i pad m a1[i] ... ak[i]
    counttomark 3 add -3 roll pop pop pop % a1[i] ... ak[i]
} bind def 

/pick { % vk vk-1 ... v1 v0 -- vk-1 ... v1 v0 vk
    1 add -1 roll
} bind def

/store-near-top { % v1 ... vk s1 ... sj k j -- [v1 ... vk] s1 ... sj
    dup 3 1 roll  % v1 ... vk s1 ... sj j k j
    2 add         % v1 ... vk s1 ... sj j k j+2
    1 roll        % v1 ... vk k s1 ... sj j
    array astore  % v1 ... vk k [s1 ... sj]
    exch dup      % v1 ... vk [s1 ... sj] k k
    3 1 roll      % v1 ... vk k [s1 ... sj] k
    2 add 1 roll  % [s1 ... sj] v1 ... vk k
    array astore  % [s1 ... sj] [v1 ... vk]
    exch          % [v1 ... vk] [s1 ... sj]
    aload pop     % [v1 ... vk] s1 ... sj
} bind def

/length-or-1 { % length of the array or 1 if not an array
    dup type /arraytype eq {
        length
    } {
        pop 1
    } ifelse
} bind def

/length-or-0 { % length of the array or 0 if not an array
    dup type /arraytype eq {
        length
    } {
        pop 0
    } ifelse
} bind def

/length-of-longest { % [a1 ... ak] -- n
    0 exch {
        length-or-1
        max
    } forall
} bind def

/azipwithaux { % a f initial-contents apply-from kget -- [*initial-contents a[0][0] a[1][0] ... a[k][0] ... a[k][apply-from-1] f! ... a[k][a.longest-length] f!]    
    4 index length-of-longest [ % a f initial-contents apply-from kget n [
    4 pick aload pop             % a f apply-from kget n [ *initial-contents
    0 1 counttomark 1 add pick 1 sub % a f apply-from kget n [ *initial-contents 0 1 n-1
    { % a f apply-from kget [ ... i
        dup counttomark 4 add index 3 1 roll % a f apply-from kget [ ... a i i
        counttomark 1 add 1 roll      % a f apply-from kget i [ ... a i
        counttomark 2 add index exec  % a f apply-from kget i [ ... ai
        counttomark 1 add pick        % a f apply-from kget [ ... ai i
        counttomark 2 add index       % a f apply-from kget [ ... ai i apply-from
        ge { % a f apply-from kget [ ... ai i>=apply-from
            counttomark 3 add index
            exec
        } if
    } for
    ]
    5 1 roll pop pop pop pop
} bind def

/azipwith { % a f initial-contents apply-from -- [*initial-contents a[0][0] a[1][0] ... a[k][0] ... a[k][apply-from-1] f! ... a[k][a.longest-length] f!]
    /items-at cvx azipwithaux
} bind def

/azipwithpad { % a f initial-contents apply-from padding -- [*initial-contents a[0][0] a[1][0] ... a[k][0] ... a[k][apply-from-1] f! ... a[k][a.longest-length] f!]
    /items-at-pad cvx 2 array astore cvx  % a f initial-contents apply-from get
    azipwithaux
} bind def

/each { % [a1 a2 ... an] f -- [a1 f a2 f ... an f]
    1 1 store-near-top
    [] 0 azipwith
} bind def

/zipwith { % a1 a2 ... ak f k -- [a1[s1] ... ak[1] f ... a1[n] ... ak[n] f]
    1 store-near-top
    [] 0
    azipwith
} bind def

/reduce { % [a1 a2 ... an] f -- a1 f a2 f ... an f
    1 1 store-near-top
    [] 1 azipwith aload pop
} bind def

/fold { % [a1 a2 ... an] f v1 -- v1 a1 f a2 f ... an f
    1 2 store-near-top
    enlist 0 azipwith aload pop
} bind def

/scan { % [a1 a2 ... an] f
    [ 3 1 roll
    2 /copy cvx 3 -1 roll /exec cvx /exch cvx /pop cvx  % [ A 2 copy f exec exch pop
    6 array astore cvx  % A {2 copy f exch pop}
    reduce
    ]
} bind def

/take { % [a1 a2 ... an] k -- [a1 ... ak]
    range { get-with-wrap } eachright
} bind def

/drop-positive { % [a1 a2 ... an] k -- [ak+1 ... an]
    2 copy exch length % A k k n
    ge {pop pop []}
    {
        [ 3 -1 roll   % k [ A
        reverse aload pop % k [ an ... a2 a1 
        counttomark 2 add -1 roll % [ an ... a2 a1 k 
        {pop} repeat
        ]
        reverse
    } ifelse
} bind def

/drop { % A k -- A'
    dup 0 lt { % A k
        neg
        exch reverse exch % Ar -k
        drop-positive
        reverse
    } {
        drop-positive
    } ifelse
} bind def

/reverse { % [a1 a2 ... an] -- [an ... a2 a1]
    [ exch
        { counttomark 1 roll } forall
    ]
} bind def

/no-arrays { % [v1 ... vk] -- bool
    {type /arraytype ne} each {and} reduce
} bind def

/kno-arrays { % v1 ... vk k -- bool
    array astore no-arrays
} bind def

/rank-polymorphic { % v1 ... vk f k - effects of f
    dup 2 add copy exch pop kno-arrays { % v1 ... vk f k
        pop exec
    } { % v1 ... vk f k
        2 copy /rank-polymorphic cvx % v1 ... vk f k f k rank-polymorphic
        3 array astore cvx           % v1 ... vk f k {f k rank-polymorphic}
        3 -1 roll pop                % v1 ... vk k {f k rank-polymorphic}
        exch                         % v1 ... vk {f k rank-polymorphic} k
        zipwith
    } ifelse
} bind def

/- {
    {sub} 2 rank-polymorphic
} bind def

/+ {
    {add} 2 rank-polymorphic
} bind def

/& {
    {min} 2 rank-polymorphic
} bind def

/ieq {
    {eq {1}{0} ifelse} 2 rank-polymorphic
} bind def

/* {
    {mul} 2 rank-polymorphic
} bind def

/| {
    {max} 2 rank-polymorphic
} bind def

/! {
    {exch mod} 2 rank-polymorphic
} bind def

/right {
    exch pop
} bind def

/enlist {
    1 array astore
} bind def

/eachleft { % [a11 a12 ... a1n] a2 f -- [(a11 a2 f) (a12 a2 f) ... (a1n a2 f)]
    3 1 roll
    enlist
    3 -1 roll    
    2 zipwith
} bind def

/eachright { % a1 [a21 a22 ... a2n] f -- [(a1 a21 f) (a1 a22 f) ... (an a2n f)]
    3 -1 roll
    enlist
    3 1 roll
    2 zipwith
} bind def

/pair {
    2 array astore
} bind def

/cross { % a1 a2 f -- [[a1[1] a2[1]] [a1[1] a2[2]] ... [a1[n] a2[n]]]
    /eachright cvx
    /aload cvx
    /pop cvx
    4 array astore cvx
    eachleft
} bind def

/rotate { % a by
    [      % a by [
    3 -1 roll % by [ a
    aload pop % by [ a1 a2 ... an
    counttomark % by [ a1 a2 ... an n
    counttomark 2 add -1 roll % [ a1 a2 ... an n by
    roll
    ]
} bind def

/rotate-each { % m by
    {rotate} eachleft
} bind def

/rotate2d { % m [vby hby]
    aload pop % m vby hby
    3 1 roll  % hby m vby
    rotate    % hby m'
    exch      % m' hby
    rotate-each
} bind def

/range { % n -- [0 1 ... n-1]
    [ 0 1 4 -1 roll 1 sub % [ 0 1 n-1
    {} for
    ]
} bind def

/chunk { % items block-size num-blocks
    2 copy mul % items block-size num-blocks total-count
    4 -1 roll  % block-size num-blocks total-count items
    exch take  % block-size num-blocks all-items
    enlist
    3 1 roll % [all-items] block-size num-blocks
    range
    { % all-items block-size blocks-skipped
        1 index mul % all-items block-size num-to-skip
        3 -1 roll % block-size num-to-skip all-items
        exch drop % block-size remaining-items
        exch take
    } 3 zipwith
} bind def

/reshape { % items dims -- ndarray
    dup length 
    1 eq { % items dims
        aload pop take
    } { % items dims
        dup 1 drop % items dims remaining-dims
        3 1 roll   % remaining-dims items dims
        0 get      % remaining-dims items d
        2 index {mul} reduce % remaining-dims items d size
        exch       % remaining-dims items size d
        chunk % remaining-dims chunked-items
        exch
        {reshape}
        eachleft
    } ifelse
} bind def

/getnd { % A [i0 ... ik]
    {get-with-wrap}
    3 -1 roll fold
} bind def

/getndpad { % A [i0 ... ik] pad
    /get-with-pad cvx 2 array astore cvx
    3 -1 roll fold
} bind def

/shape { % A
    dup type /arraytype eq not { % scalar, return []
        pop []
    } { % A                      % empty array, return [0]
        dup length 0 eq {
           pop [0]
        } { % A                  % no nested, return [length]
           dup no-arrays {
              length 1 array astore
           } {                   % recursively compute shapes and max over them
              dup length exch    % n A
              {shape} each {
                2 array astore {max} [] 0 0 azipwithpad
              } reduce           % n dims'
              [
                3 1 roll aload pop
              ]                  % dims
           } ifelse
        } ifelse
    } ifelse
} bind def

/shape-indexes { % dims -- ixs
    {range} each {{pair} cross} reduce
} bind def

/array-indexes { % A -- ixs
    shape shape-indexes
} bind def

/takepad { % A dims pad -- A'
    1 index 4 1 roll % dims A dims pad
    2 pick enlist
    2 pick shape-indexes
    2 pick enlist  % dims [A] indexeqqs [pad]
    {
        getndpad
    } 3 zipwith  % dims values
    exch reshape
} bind def
