/dbg { % message -- 
    pstack
    ==
} bind def

/debug {
    (debug) dbg
} bind def

/get-with-wrap { % a i -- a if a is not an array else a[i % a.length]
    1 index type /arraytype eq {
        1 index length mod
        get
    } {
        pop
    } ifelse
} bind def

/items-at { % [a1 a2 ... ak] i -- a1[i] a2[i] ... ak[i]
    mark  % A i m
    3 -1 roll % i m A
    {  % i m ... aj
        counttomark 1 add index % i m ... aj i
        get-with-wrap
    } forall % i m a1[i] ... ak[i]
    counttomark 2 add -2 roll pop pop % a1[i] ... ak[i]
} bind def 

/overk { % a1 a2 ... ak f k s n -- [a1[0] ... ak[0] a1[s-1] ... ak[s-1] f a1[s] ... ak[s] f ... a1[n] ... ak[n] f]
    2 index array  % a1 a2 ... ak f k s n A
    5 1 roll       % a1 a2 ... ak A f k s n
    2 index 5 add 4 roll % f k s n a1 a2 ak ... A
    astore [   % f k s n A [
    3 index 0 eq {
        5 index exec  % run f if s is 0
    } if
    0 1 counttomark 2 add index 1 sub % f k s n A [ ... 0 1 n-1
    { % f k s n A [ ... i
        counttomark 1 roll % [ i ... 
        counttomark 1 add index % ... A
        counttomark 1 sub index % ... A i
        items-at   % ... a1i a2i ... aki
        counttomark -1 roll
        counttomark 3 add index 1 sub % ... i s-1
        ge
        { counttomark 5 add index exec } if
    } for
    ]
    6 1 roll
    5 { pop } repeat
} bind def

/each { % [a1 a2 ... an] f -- [a1 f a2 f ... an f]
    1 1 3 index length    % a f 1 1 n
    overk
} bind def

/zipwith { % a1 a2 ... ak f k -- [a1[s1] ... ak[1] f ... a1[n] ... ak[n] f]
    dup 2 add copy exch pop % a1 a2 ... ak f k a1 a2 ... ak k 
    longest-length
    zipwithn
} bind def

/zipwithn { % a1 a2 ... ak f k n -- [a1[s1] ... ak[1] f ... a1[n] ... ak[n] f]
    1 exch overk
} bind def

/reduce { % [a1 a2 ... an] f -- a1 f a2 f ... an f
    1 2 3 index length    % a f 1 2 n
    overk aload pop
} bind def

/xdebug { % f --
    dup debug
    exec
} bind def

/max {
    2 copy gt {
        pop
    } {
        exch pop
    } ifelse
} bind def

/longest-length { % a1 ... ak k -- length of longest
    array astore {
        dup type /arraytype ne {
            pop 1
        } {
            length
        } ifelse
    } each
    {max} reduce
} bind def

/no-arrays { % v1 ... vk k -- bool
    array astore {type /arraytype ne} each
    {and} reduce
} bind def

/rank-polymorphic { % v1 ... vk f k - effects of f
    dup 2 add copy exch pop no-arrays { % v1 ... vk f k
        pop exec
    } { % v1 ... vk f k
        2 copy /rank-polymorphic cvx % v1 ... vk f k f k rank-polymorphic
        3 array astore cvx           % v1 ... vk f k {f k rank-polymorphic}
        3 -1 roll pop                % v1 ... vk k {f k rank-polymorphic}
        exch                         % v1 ... vk {f k rank-polymorphic} k
        zipwith
    } ifelse
} bind def

/+ {
    {add} 2 rank-polymorphic
} bind def

/! {
    {exch mod} 2 rank-polymorphic
} bind def

/enlist {
    1 array astore
} bind def

/eachleft { % [a11 a12 ... a1n] a2 f -- [(a11 a2 f) (a12 a2 f) ... (a1n a2 f)]
    3 1 roll
    enlist
    3 -1 roll    
    2 zipwith
} bind def

/eachright { % a1 [a21 a22 ... a2n] f -- [(a1 a21 f) (a1 a22 f) ... (an a2n f)]
    3 -1 roll
    enlist
    3 1 roll
    2 zipwith
} bind def

/pair {
    2 array astore
} bind def

/cross { % a1 a2 f -- [[a1[1] a2[1]] [a1[1] a2[2]] ... [a1[n] a2[n]]]
    /eachright cvx
    /aload cvx
    /pop cvx
    4 array astore cvx
    eachleft
} bind def

/rot { % a by
    [      % a by [
    3 -1 roll % by [ a
    aload pop % by [ a1 a2 ... an
    counttomark % by [ a1 a2 ... an n
    counttomark 2 add -1 roll % [ a1 a2 ... an n by
    roll
    ]
} bind def

/rotate-each { % m by
    {rot} eachleft
} def
